"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.getImageMetadata = getImageMetadata;
exports.generateImageData = generateImageData;

var _utils = require("./utils");

var _ = require(".");

var _safeSharp = _interopRequireDefault(require("./safe-sharp"));

var _pluginOptions = require("./plugin-options");

/* eslint-disable no-unused-expressions */
const metadataCache = new Map();

async function getImageMetadata(file, getDominantColor) {
  if (!getDominantColor) {
    // If we don't need the dominant color we can use the cheaper size function
    const {
      width,
      height,
      type
    } = await (0, _.getImageSizeAsync)(file);
    return {
      width,
      height,
      format: type
    };
  }

  let metadata = metadataCache.get(file.internal.contentDigest);

  if (metadata && process.env.NODE_ENV !== `test`) {
    return metadata;
  }

  const pipeline = (0, _safeSharp.default)(file.absolutePath);
  const {
    width,
    height,
    density,
    format
  } = await pipeline.metadata();
  const {
    dominant
  } = await pipeline.stats(); // Fallback in case sharp doesn't support dominant

  const dominantColor = dominant ? (0, _utils.rgbToHex)(dominant.r, dominant.g, dominant.b) : `#000000`;
  metadata = {
    width,
    height,
    density,
    format,
    dominantColor
  };
  metadataCache.set(file.internal.contentDigest, metadata);
  return metadata;
}

async function generateImageData({
  file,
  args,
  pathPrefix,
  reporter,
  cache
}) {
  const {
    layout = `fixed`,
    placeholder = `dominantColor`,
    tracedSVGOptions = {}
  } = args;
  const metadata = await getImageMetadata(file, placeholder === `dominantColor`);
  const imageSizes = (0, _utils.calculateImageSizes)({
    file,
    layout,
    ...args,
    imgDimensions: metadata,
    reporter
  });
  const transforms = imageSizes.sizes.map(outputWidth => {
    const width = Math.round(outputWidth);
    const transform = (0, _pluginOptions.createTransformObject)({ ...args,
      width,
      height: Math.round(width / imageSizes.aspectRatio),
      toFormat: args.toFormat || metadata.format
    });
    if (pathPrefix) transform.pathPrefix = pathPrefix;
    return transform;
  });
  const images = (0, _.batchQueueImageResizing)({
    file,
    transforms,
    reporter
  });
  const srcSet = (0, _utils.getSrcSet)(images);
  const widthOfMaxSize = imageSizes.isTopSizeOverriden ? metadata.width : imageSizes.presentationWidth;
  const sizes = args.sizes || (0, _utils.getSizes)(widthOfMaxSize, layout);
  const primaryIndex = imageSizes.sizes.findIndex(size => size === widthOfMaxSize);

  if (primaryIndex === -1) {
    reporter.panic(`No image of the specified size found. Images may not have been processed correctly.`);
  }

  const primaryImage = images[primaryIndex];

  if (!(images === null || images === void 0 ? void 0 : images.length)) {
    return undefined;
  }

  const imageProps = {
    layout,
    placeholder: undefined,
    images: {
      fallback: {
        src: primaryImage.src,
        srcSet,
        sizes
      },
      sources: []
    }
  };

  if (args.webP) {
    var _imageProps$images$so;

    const transforms = imageSizes.sizes.map(outputWidth => {
      const width = Math.round(outputWidth);
      const transform = (0, _pluginOptions.createTransformObject)({ ...args,
        width,
        height: Math.round(width / imageSizes.aspectRatio),
        toFormat: `webp`
      });
      return transform;
    });
    const webpImages = (0, _.batchQueueImageResizing)({
      file,
      transforms,
      reporter
    });
    const webpSrcSet = (0, _utils.getSrcSet)(webpImages);
    (_imageProps$images$so = imageProps.images.sources) === null || _imageProps$images$so === void 0 ? void 0 : _imageProps$images$so.push({
      srcSet: webpSrcSet,
      type: `image/webp`,
      sizes
    });
  }

  if (placeholder === `blurred`) {
    const {
      src: fallback
    } = await (0, _.base64)({
      file,
      args: { ...args,
        width: args.base64Width,
        height: args.base64Height
      },
      reporter
    });
    imageProps.placeholder = {
      fallback
    };
  } else if (placeholder === `tracedSVG`) {
    const fallback = await (0, _.traceSVG)({
      file,
      args: tracedSVGOptions,
      fileArgs: args,
      cache,
      reporter
    });
    imageProps.placeholder = {
      fallback
    };
  } else if (metadata.dominantColor) {
    imageProps.backgroundColor = metadata.dominantColor;
  }

  primaryImage.aspectRatio = primaryImage.aspectRatio || 1;

  switch (layout) {
    case `fixed`:
      imageProps.width = imageSizes.presentationWidth;
      imageProps.height = imageSizes.presentationHeight;
      break;

    case `fluid`:
      imageProps.width = 1;
      imageProps.height = 1 / primaryImage.aspectRatio;
      break;

    case `constrained`:
      imageProps.width = args.maxWidth || primaryImage.width || 1;
      imageProps.height = (imageProps.width || 1) / primaryImage.aspectRatio;
  }

  return imageProps;
}